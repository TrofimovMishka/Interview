Interview questions:

	- Differences interface vs abstract classes:
	
    . abstract keyword is used to create an abstract class and it can be used with methods also whereas interface keyword is used to create interface and it can’t be used with methods.
    . Subclasses use extends keyword to extend an abstract class and they need to provide implementation of all the declared methods in the abstract class unless the subclass is also an abstract class whereas subclasses use implements keyword to implement interfaces and should provide implementation for all the methods declared in the interface.
    . Abstract classes can have methods with implementation whereas interface provides absolute abstraction and can’t have any method implementations. Note that from Java 8 onwards, we can create default and static methods in interface that contains the method implementations.
    . Abstract classes can have constructors but interfaces can’t have constructors.
    . Abstract class have all the features of a normal java class except that we can’t instantiate it. We can use abstract keyword to make a class abstract but interfaces are a completely different type and can have only public static final constants and method declarations.
    . Abstract classes methods can have access modifiers as public, private, protected, static but interface methods are implicitly public, private (static, non-static - Since Java 9) and abstract, we can’t use any other access modifiers with interface methods.
    . A subclass can extend only one abstract class but it can implement multiple interfaces.
    . Abstract classes can extend other class and implement interfaces but interface can only extend other interfaces.
    . We can run an abstract class if it has main() method but we can’t run an interface because they can’t have main method implementation.
    . Interfaces are used to define contract for the subclasses whereas abstract class also define contract but it can provide other methods implementations for subclasses to use.
    
    	- HashMap vs HashTable - Since JDK 1.8, Hashtable has been deprecated 1) Firstly, Hashtable is thread-safe and can be shared between multiple threads in the application. HashMap is not synchronized.
    	2) Another difference is null handling. HashMap allows adding one Entry with null as key as well as many entries with null as value. In contrast, Hashtable doesn’t allow null at all.
    	3) HashMap uses Iterator to iterate over values, whereas Hashtable has Enumerator for the same. 
    	Iterator является преемником Enumerator, который устраняет его несколько недостатков.
    	
    	 The Iterator is a successor of Enumerator that eliminates its few drawbacks.
    	 For example, Iterator has a remove() method to remove elements from underlying collections. The Iterator is a fail-fast iterator. In other words, it throws a ConcurrentModificationException when the underlying collection is modified while iterating. Итератор — это отказоустойчивый итератор. Другими словами, он генерирует исключение ConcurrentModificationException, когда базовая коллекция изменяется во время итерации.
    	
	- Optimistic vs pesimistic locking - Optimistic locking is a technique for SQL database applications that does not hold row locks between selecting and updating or deleting a row. The application is written to optimistically assume that unlocked rows are unlikely to change before the update or delete operation.
	
	- transient key word - When we mark any variable as transient, then that variable is not serialized.
	
	- Circuit bracker pattern - implementation (Resilience4j).  Helps us in preventing a cascade of failures when a remote service is down. After a number of failed attempts, we can consider that the service is unavailable/overloaded and eagerly reject all subsequent requests to it
	
	- Singlenton, prototype in Spring Boot
	
	- Disadvantages of microservice architecture - high latency
	
	- What have less coupling, Inheritance vs. Aggregation - inheritance leads to higher coupling. Composition = less coupling
		Problem of Inheritance - When reading through a procedure that lives in an inheritance stack you find yourself bouncing up and down levels of inheritance and getting lost. It’s called the yo-yo problem.
		
	- Aggregation vs Composition - Aggregation differs from ordinary composition in that it does not imply ownership. In Spring Boot using Singlenton in class (variable) is Aggregation, but using Prototype - is Composition (The prototype will destroy then the used class will destroy as well). But in aggregation - singlenton not will destroy.
